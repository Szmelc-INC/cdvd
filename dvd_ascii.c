// dvd_ascii.c — Bouncing ASCII/Unicode logo with smooth ordered-dither GHOST trail
// Hotkeys:
//   ←/→  : speed -/+ 1            (clamp 1..200)
//   ↑/↓  : FPS   -/+ 1            (clamp 5..240)
//   t    : toggle trail (on sets 5s if 0; off clears ghosts)
//   y/u  : trail decay -/+ 1s     (clamp 0..60)
//   m    : cycle mask mode: OFF → EDGES → ALL → OFF
//   i    : toggle HUD on/off
// Masking modes (CLI):
//   --mask-blanks : skip ALL whitespace/zero-width glyphs (logo + ghosts)
//   --mask-edges  : skip only leading/trailing blanks per row
//
// Build:
//   xxd -i -n dvd_logo logo.txt > logo.inc
//   gcc -O2 -Wall -Wextra -std=c11 dvd_ascii.c -lncursesw -lm -o dvd
//
// Run:
//   ./dvd [-f fps] [-s speed] [-t decay_sec] [-L logo.txt] [--info] [--mask-edges|--mask-blanks]

#define _XOPEN_SOURCE 700
#define _XOPEN_SOURCE_EXTENDED 1
#define NCURSES_WIDECHAR 1

#include <locale.h>
#include <wchar.h>
#include <wctype.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <time.h>
#include <math.h>
#include <unistd.h>
#include <ncurses.h>
#include <stdbool.h>

// ---------- embedded logo bytes generated by: xxd -i -n dvd_logo logo.txt ----------
#include "logo.inc"   // unsigned char dvd_logo[]; unsigned int dvd_logo_len;
// -----------------------------------------------------------------------------------

typedef struct {
    wchar_t **rows;   // wide strings (null-terminated)
    int     *wcell;   // display width (cells) per row
    int     *first;   // first non-invisible glyph start col (cells)
    int     *last;    // last  non-invisible glyph end   col (cells)
    int       h;      // number of rows
    int       w;      // max display width (cells)
} WLogo;

typedef struct {
    int y, x;           // integer position in cells
    float life;         // seconds remaining
    float total;        // original life
    unsigned char col;  // color pair 1..7
} Ghost;

typedef struct {
    Ghost *v;
    int n, cap;
} GhostList;

typedef enum { MASK_NONE = 0, MASK_ALL = 1, MASK_EDGES = 2 } MaskMode;

static void die_nc(const char *msg) {
    endwin();
    fprintf(stderr, "Error: %s\n", msg);
    exit(1);
}

/* -------------------- logo loading (UTF-8 -> wide) -------------------- */

static wchar_t *mb_to_wide(const char *mb) {
    mbstate_t st = (mbstate_t){0};
    const char *src = mb;
    size_t need = mbsrtowcs(NULL, &src, 0, &st);
    if (need == (size_t)-1) return NULL;
    wchar_t *w = calloc(need + 1, sizeof(wchar_t));
    if (!w) return NULL;
    st = (mbstate_t){0}; src = mb;
    size_t got = mbsrtowcs(w, &src, need, &st);
    if (got == (size_t)-1) { free(w); return NULL; }
    w[got] = L'\0';
    return w;
}

// strict “invisible glyph” test (beyond iswspace)
static inline bool is_invisible_glyph(wchar_t wc) {
    if (wc == 0) return true;
    if (iswspace(wc)) return true;
    if (wc == 0x00A0) return true;                 // NBSP
    if (wc == 0x2800) return true;                 // Braille blank
    if (wc == 0xFEFF) return true;                 // BOM / ZWNBSP
    if (wc == 0x200B || wc == 0x200C || wc == 0x200D) return true; // ZWSP/ZWNJ/ZWJ
    if (wc == 0x2060) return true;                 // WORD JOINER
    if (wc == 0x3164 || wc == 0x115F || wc == 0xFFA0) return true; // Hangul fillers, halfwidth NBSP
    if ((wc >= 0x2000 && wc <= 0x200A) || wc == 0x202F || wc == 0x205F || wc == 0x3000) return true;
    return false;
}

static void push_row(WLogo *L, wchar_t *w, int width) {
    static int cap = 0;
    if (L->h >= cap) {
        cap = cap ? cap * 2 : 8;
        L->rows  = realloc(L->rows,  (size_t)cap * sizeof(*L->rows));
        L->wcell = realloc(L->wcell, (size_t)cap * sizeof(*L->wcell));
        L->first = realloc(L->first, (size_t)cap * sizeof(*L->first));
        L->last  = realloc(L->last,  (size_t)cap * sizeof(*L->last));
        if (!L->rows || !L->wcell || !L->first || !L->last) die_nc("OOM");
    }
    // compute first/last visible extents in display cells for this row
    int col = 0;
    int first = -1, last = -1;
    for (const wchar_t *p = w; *p; ++p) {
        int cw = wcwidth(*p);
        if (cw < 0) cw = 1;
        if (cw == 0) continue; // combining mark shouldn't influence extents
        if (!is_invisible_glyph(*p)) {
            if (first < 0) first = col;
            last = col + cw - 1;
        }
        col += cw;
    }
    L->rows[L->h]  = w;
    L->wcell[L->h] = width;
    L->first[L->h] = first;
    L->last[L->h]  = last;

    if (width > L->w) L->w = width;
    L->h++;
}

static WLogo load_logo_from_bytes(const unsigned char *buf, size_t len) {
    WLogo L = (WLogo){0};
    size_t i = 0, line_start = 0;

    while (i <= len) {
        if (i == len || buf[i] == '\n') {
            size_t line_len = i - line_start;
            if (line_len && buf[line_start + line_len - 1] == '\r') line_len--;

            char *mb = malloc(line_len + 1);
            if (!mb) die_nc("OOM");
            memcpy(mb, buf + line_start, line_len);
            mb[line_len] = '\0';

            wchar_t *w = mb_to_wide(mb);
            free(mb);
            if (!w) die_nc("embedded logo: invalid UTF-8 for this locale");

            int width = wcswidth(w, wcslen(w));
            if (width < 0) width = (int)wcslen(w);
            push_row(&L, w, width);

            line_start = i + 1;
        }
        i++;
    }
    if (L.h == 0) die_nc("embedded logo is empty");
    return L;
}

static WLogo load_logo_from_file(const char *path) {
    FILE *f = fopen(path, "rb");
    if (!f) { char b[512]; snprintf(b, sizeof(b), "cannot open '%s': %s", path, strerror(errno)); die_nc(b); }

    fseek(f, 0, SEEK_END);
    long sz = ftell(f);
    if (sz < 0) { fclose(f); die_nc("ftell failed"); }
    fseek(f, 0, SEEK_SET);

    unsigned char *buf = malloc((size_t)sz);
    if (!buf) { fclose(f); die_nc("OOM"); }
    size_t rd = fread(buf, 1, (size_t)sz, f);
    fclose(f);
    if (rd != (size_t)sz) { free(buf); die_nc("short read"); }

    WLogo r = load_logo_from_bytes(buf, rd);
    free(buf);
    return r;
}

static void free_logo(WLogo *L) {
    if (!L) return;
    for (int i = 0; i < L->h; i++) free(L->rows[i]);
    free(L->rows);
    free(L->wcell);
    free(L->first);
    free(L->last);
    *L = (WLogo){0};
}

/* ------------------------ timing & colors ------------------------ */

static double now_sec(void) {
    struct timespec ts; clock_gettime(CLOCK_MONOTONIC, &ts);
    return (double)ts.tv_sec + (double)ts.tv_nsec * 1e-9;
}

static void init_colors(void) {
    if (!has_colors()) return;
    start_color();
    use_default_colors();
    init_pair(1, COLOR_RED,     -1);
    init_pair(2, COLOR_GREEN,   -1);
    init_pair(3, COLOR_YELLOW,  -1);
    init_pair(4, COLOR_BLUE,    -1);
    init_pair(5, COLOR_MAGENTA, -1);
    init_pair(6, COLOR_CYAN,    -1);
    init_pair(7, COLOR_WHITE,   -1);
}

/* --------------------------- ghosts --------------------------- */

static void ghosts_init(GhostList *G, int initial_cap) {
    G->n = 0;
    G->cap = initial_cap > 0 ? initial_cap : 256;
    G->v = malloc((size_t)G->cap * sizeof(Ghost));
    if (!G->v) die_nc("OOM");
}

static void ghosts_free(GhostList *G) {
    free(G->v);
    *G = (GhostList){0};
}

static void ghosts_clear(GhostList *G) {
    G->n = 0;
}

static void ghosts_add(GhostList *G, int y, int x, float decay, unsigned char col) {
    if (decay <= 0.0f) return;
    if (G->n >= G->cap) {
        G->cap *= 2;
        G->v = realloc(G->v, (size_t)G->cap * sizeof(Ghost));
        if (!G->v) die_nc("OOM");
    }
    G->v[G->n++] = (Ghost){ .y = y, .x = x, .life = decay, .total = decay, .col = col };
}

static void ghosts_age(GhostList *G, float dt) {
    for (int i = 0; i < G->n; i++) {
        if (G->v[i].life > 0.0f) {
            G->v[i].life -= dt;
            if (G->v[i].life < 0.0f) G->v[i].life = 0.0f;
        }
    }
}

static void ghosts_compact(GhostList *G) {
    int w = 0;
    for (int i = 0; i < G->n; i++) {
        if (G->v[i].life > 0.0f) G->v[w++] = G->v[i];
    }
    G->n = w;
}

/* -------------------- ordered-dither fade helpers -------------------- */

static const unsigned char BAYER8[8][8] = {
    { 0,32, 8,40, 2,34,10,42 },
    {48,16,56,24,50,18,58,26 },
    {12,44, 4,36,14,46, 6,38 },
    {60,28,52,20,62,30,54,22 },
    { 3,35,11,43, 1,33, 9,41 },
    {51,19,59,27,49,17,57,25 },
    {15,47, 7,39,13,45, 5,37 },
    {63,31,55,23,61,29,53,21 },
};

static inline int fade_keep_bayer(int x, int y, float r) {
    float q = powf(r, 1.5f);
    int thresh = (int)(q * 64.0f + 0.5f);
    int b = BAYER8[y & 7][x & 7];
    return thresh > b;
}

/* ------------------------- draw routines ------------------------- */

static void ghosts_draw(const GhostList *G, const WLogo *LOGO, int max_rows, int cols, MaskMode mode) {
    for (int i = 0; i < G->n; i++) {
        const Ghost *g = &G->v[i];
        if (g->life <= 0.0f) continue;

        float r = g->life / (g->total > 0.0f ? g->total : 1.0f);
        attr_t attr = (r > 0.66f) ? A_NORMAL : A_DIM; // hint; dither does the work

        if (has_colors() && g->col >= 1 && g->col <= 7) attron(COLOR_PAIR(g->col) | attr);
        else attron(attr);

        for (int row = 0; row < LOGO->h; row++) {
            int y = g->y + row;
            if (y < 0 || y >= max_rows) continue;

            int screen_x = g->x;
            int col = 0; // row-local display column
            const wchar_t *p = LOGO->rows[row];

            while (*p) {
                int cw = wcwidth(*p);
                if (cw < 0) cw = 1;

                // combining mark (zero-width)
                if (cw == 0) {
                    if (mode == MASK_NONE ||
                        (mode == MASK_ALL ? false
                                          : (LOGO->first[row] <= LOGO->last[row] && col >= LOGO->first[row] && col <= LOGO->last[row]))) {
                        if (screen_x >= 0 && screen_x < cols) {
                            if (fade_keep_bayer(screen_x, y, r)) mvaddnwstr(y, screen_x, p, 1);
                        }
                    }
                    p++; // no col/screen_x advance
                    continue;
                }

                bool draw_this = true;
                if (mode == MASK_ALL) {
                    if (is_invisible_glyph(*p)) draw_this = false;
                } else if (mode == MASK_EDGES) {
                    if (is_invisible_glyph(*p)) {
                        int first = LOGO->first[row], last = LOGO->last[row];
                        if (!(first <= last)) draw_this = false; // whole row invisible → skip
                        else if ((col + cw - 1) < first || col > last) draw_this = false;
                    }
                }
                if (draw_this && !(screen_x + cw <= 0 || screen_x >= cols)) {
                    if (fade_keep_bayer(screen_x, y, r)) mvaddnwstr(y, screen_x, p, 1);
                }

                screen_x += cw;
                col      += cw;
                p++;
            }
        }

        if (has_colors() && g->col >= 1 && g->col <= 7) attroff(COLOR_PAIR(g->col) | attr);
        else attroff(attr);
    }
}

static void draw_logo_clip(const WLogo *L, int top, int left, int rows, int cols, MaskMode mode) {
    for (int i = 0; i < L->h; i++) {
        int y = top + i;
        if (y < 0 || y >= rows) continue;

        int screen_x = left;
        int col = 0; // row-local display column
        const wchar_t *p = L->rows[i];

        while (*p) {
            int cw = wcwidth(*p);
            if (cw < 0) cw = 1;

            if (cw == 0) { // combining mark
                if (mode == MASK_NONE ||
                    (mode == MASK_ALL ? false
                                      : (L->first[i] <= L->last[i] && col >= L->first[i] && col <= L->last[i]))) {
                    if (screen_x >= 0 && screen_x < cols) mvaddnwstr(y, screen_x, p, 1);
                }
                p++;
                continue;
            }

            bool draw_this = true;
            if (mode == MASK_ALL) {
                if (is_invisible_glyph(*p)) draw_this = false;
            } else if (mode == MASK_EDGES) {
                if (is_invisible_glyph(*p)) {
                    int first = L->first[i], last = L->last[i];
                    if (!(first <= last)) draw_this = false;
                    else if ((col + cw - 1) < first || col > last) draw_this = false;
                }
            }

            if (draw_this && !(screen_x + cw <= 0 || screen_x >= cols)) {
                mvaddnwstr(y, screen_x, p, 1);
            }
            screen_x += cw;
            col      += cw;
            p++;
        }
    }
}

/* --------------------------------- main --------------------------------- */

int main(int argc, char **argv) {
    setlocale(LC_ALL, "");

    double fps   = 20.0;      // Found out 20fps looks smoother than 60
    double speed = 28.0;      // cells/sec seems about right
    double t_decay = 0.0;     // seconds (0 = no trail)
    bool   trail_enabled = false;
    int show_info = 0;
    MaskMode mask_mode = MASK_NONE;
    const char *logo_path = NULL; // NULL => use embedded logo.inc

    for (int i = 1; i < argc; i++) {
        if (!strcmp(argv[i], "-f") && i+1 < argc) fps = atof(argv[++i]);
        else if (!strcmp(argv[i], "-s") && i+1 < argc) speed = atof(argv[++i]);
        else if (!strcmp(argv[i], "-t") && i+1 < argc) { t_decay = atof(argv[++i]); trail_enabled = (t_decay > 0.0); }
        else if (!strcmp(argv[i], "-L") && i+1 < argc) logo_path = argv[++i];
        else if (!strcmp(argv[i], "--info")) show_info = 1;
        else if (!strcmp(argv[i], "--mask-blanks")) mask_mode = MASK_ALL;
        else if (!strcmp(argv[i], "--mask-edges"))  mask_mode = MASK_EDGES; // wins if both given
        else {
            fprintf(stderr,
                "Usage: %s [-f fps] [-s speed] [-t decay_sec] [-L logo.txt] [--info] [--mask-edges|--mask-blanks]\n",
                argv[0]);
            return 1;
        }
    }

    // If user gave -t 0, trail_enabled stays false; otherwise explicit -t>0 turns it on.
    if (!trail_enabled && t_decay > 0.0) trail_enabled = true;

    WLogo LOGO = logo_path
        ? load_logo_from_file(logo_path)
        : load_logo_from_bytes(dvd_logo, (size_t)dvd_logo_len);

    srand((unsigned)time(NULL));

    initscr(); cbreak(); noecho();
    keypad(stdscr, TRUE);
    nodelay(stdscr, TRUE);
    curs_set(0);
    init_colors();

    int rows, cols; getmaxyx(stdscr, rows, cols);
    int hud_rows = show_info ? 1 : 0;
    int content_rows = rows - hud_rows;
    if (content_rows < 1) content_rows = rows;

    // Start centered in content area
    double x = (cols - LOGO.w) > 0 ? (cols - LOGO.w) / 2.0 : 0.0;
    double y = (content_rows - LOGO.h) > 0 ? (content_rows - LOGO.h) / 2.0 : 0.0;

    // Unit diagonal direction (constant speed)
    double dx = (rand() & 1) ? 1.0 : -1.0;
    double dy = (rand() & 1) ? 1.0 : -1.0;
    double invlen = 1.0 / sqrt(dx*dx + dy*dy);
    dx *= invlen; dy *= invlen;

    int color = 1 + rand() % 7;

    GhostList ghosts = {0};
    ghosts_init(&ghosts, 256);

    // clamp helpers
    #define CLAMP(v,lo,hi) do{ if((v)<(lo)) (v)=(lo); else if((v)>(hi)) (v)=(hi); }while(0)

    CLAMP(fps, 5.0, 240.0);
    CLAMP(speed, 1.0, 200.0);
    CLAMP(t_decay, 0.0, 60.0);

    double frame_s = 1.0 / fps;
    double t_prev = now_sec();

    int last_gx = (int)llround(x), last_gy = (int)llround(y);
    int last_color = -1;

    while (1) {
        int ch = getch();
        if (ch == 'q' || ch == 27) break;

        // Hotkeys
        if (ch == KEY_LEFT)  { speed -= 1.0; CLAMP(speed, 1.0, 200.0); }
        if (ch == KEY_RIGHT) { speed += 1.0; CLAMP(speed, 1.0, 200.0); }
        if (ch == KEY_UP)    { fps   += 1.0; CLAMP(fps,   5.0, 240.0); frame_s = 1.0 / fps; }
        if (ch == KEY_DOWN)  { fps   -= 1.0; CLAMP(fps,   5.0, 240.0); frame_s = 1.0 / fps; }
        if (ch == 'y' || ch == 'Y') { t_decay -= 1.0; CLAMP(t_decay, 0.0, 60.0); }
        if (ch == 'u' || ch == 'U') { t_decay += 1.0; CLAMP(t_decay, 0.0, 60.0); }
        if (ch == 't' || ch == 'T') {
            trail_enabled = !trail_enabled;
            if (!trail_enabled) { ghosts_clear(&ghosts); }
            else if (t_decay <= 0.0) { t_decay = 5.0; } // default when enabling
        }
        if (ch == 'm' || ch == 'M') {
            // cycle: OFF -> EDGES -> ALL -> OFF
            mask_mode = (mask_mode == MASK_NONE) ? MASK_EDGES
                       : (mask_mode == MASK_EDGES) ? MASK_ALL
                       : MASK_NONE;
        }
        if (ch == 'i' || ch == 'I') {
            show_info = !show_info;
        }

        // Handle resize
        if (ch == KEY_RESIZE) {
            getmaxyx(stdscr, rows, cols);
        }

        // Recompute HUD/content rows every frame (covers 'i' toggle too)
        hud_rows     = show_info ? 1 : 0;
        content_rows = rows - hud_rows;
        if (content_rows < 1) content_rows = rows;

        // Clamp position within current bounds (also protects on HUD toggle)
        if (x < 0) x = 0;
        if (y < 0) y = 0;
        if (x + LOGO.w > cols) x = cols - LOGO.w;
        if (y + LOGO.h > content_rows) y = content_rows - LOGO.h;

        double t_now = now_sec();
        double dt = t_now - t_prev;
        if (dt > 0.25) dt = 0.25;
        t_prev = t_now;

        // Age & prune ghosts
        ghosts_age(&ghosts, (float)dt);
        if (ghosts.n > 0 && ghosts.v[0].life <= 0.0f) ghosts_compact(&ghosts);

        // Move logo
        x += dx * speed * dt;
        y += dy * speed * dt;

        int hitX = 0, hitY = 0;
        if (x <= 0)                         { x = 0;                    dx = fabs(dx);  hitX = 1; }
        if (x + LOGO.w >= cols)             { x = cols - LOGO.w;        dx = -fabs(dx); hitX = 1; }
        if (y <= 0)                         { y = 0;                    dy = fabs(dy);  hitY = 1; }
        if (y + LOGO.h >= content_rows)     { y = content_rows - LOGO.h;dy = -fabs(dy); hitY = 1; }

        if (hitX || hitY) {
            int newc; do { newc = 1 + rand() % 7; } while (newc == color);
            color = newc;
            if (hitX && hitY) beep();
        }

        // Drop a ghost at integer-rounded position (only if moved a cell or color changed)
        int gx = (int)llround(x), gy = (int)llround(y);
        if (trail_enabled && t_decay > 0.0 && (gx != last_gx || gy != last_gy || color != last_color)) {
            ghosts_add(&ghosts, gy, gx, (float)t_decay, (unsigned char)color);
            last_gx = gx; last_gy = gy; last_color = color;
        }

        erase();

        // 1) draw ghosts (faded)
        if (trail_enabled) {
            ghosts_draw(&ghosts, &LOGO, content_rows, cols, mask_mode);
        }

        // 2) draw live logo on top
        attr_t baseAttr = A_BOLD;
        if (has_colors()) attron(COLOR_PAIR(color) | baseAttr); else attron(baseAttr);
        draw_logo_clip(&LOGO, gy, gx, content_rows, cols, mask_mode);
        if (has_colors()) attroff(COLOR_PAIR(color) | baseAttr); else attroff(baseAttr);

        // 3) HUD at bottom if requested
        if (show_info) {
            const char *mm =
                (mask_mode == MASK_ALL)   ? "mask:ALL" :
                (mask_mode == MASK_EDGES) ? "mask:EDGES" : "mask:OFF";
            mvprintw(rows - 1, 0,
                     "[q/ESC] FPS:%3d  Speed:%3d  Trail:%s%s  Decay:%4.1fs  Logo:%dx%d  %s   ",
                     (int)(fps + 0.5), (int)(speed + 0.5),
                     trail_enabled ? "ON" : "OFF",
                     trail_enabled && t_decay <= 0.0 ? "(0s!)" : "",
                     t_decay, LOGO.w, LOGO.h, mm);
            clrtoeol();
        }

        refresh();
        int ms = (int)(frame_s * 1000.0); if (ms < 1) ms = 1;
        napms(ms);
    }

    endwin();
    ghosts_free(&ghosts);
    free_logo(&LOGO);
    return 0;
}
